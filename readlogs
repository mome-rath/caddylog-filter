#!/usr/bin/env bash

show_help() {
    local script_name;
    script_name="$(basename -- "$0")"
    echo -e "\e[34mUsage:\e[0m $script_name <start_date> <end_date> <log_file1> [<log_file2> ... <log_fileN>]" >&2
    echo -e "\e[34mExample:\e[0m $script_name '2023-10-01 00:00:00' '2023-10-31 23:59:59' /var/log/caddy/*.log" >&2
}

# Convert date string to seconds since epoch
convert_date() {
    date -d "$1" +%s 2>/dev/null
}

# Process a single log file and print lines within the specified date range
process_log_file() {
    local start_epoch="$1"
    local end_epoch="$2"
    local log_file="$3"

    while read -r line; do
        local timestamp
        local line_epoch

        # Grab the timestamp from the log line using jq
        timestamp=$(echo "$line" | jq -r '.ts' 2>/dev/null)

        # Skip if no timestamp found
        [[ -z "$timestamp" ]] && continue

        # Convert timestamp to epoch
        line_epoch="$(convert_date "@$timestamp")"

        # Skip if conversion failed
        [[ -z "$line_epoch" ]] && continue

        # Check if the line's timestamp is within the range
        if [[ $line_epoch -ge $start_epoch && $line_epoch -le $end_epoch ]]; then
            echo "$line"
        fi
    done < "$log_file"
}

# This script reads the logs from the specified log file and prints them to the console.
read_logs() {
    local start_epoch
    local end_epoch
    local start_pretty
    local end_pretty

    # Convert date strings to seconds since epoch for comparison
    start_epoch="$(convert_date "$1")"
    end_epoch="$(convert_date "$2")"
    
    # Skip if conversion failed
    if [[ -z "$start_epoch" ]]; then
        echo -e "\e[31mInvalid start date: \e[4m$1\e[24m\e[0m" >&2
        return 1
    fi
    if [[ -z "$end_epoch" ]]; then
        echo -e "\e[31mInvalid end date: \e[4m$2\e[24m\e[0m" >&2
        return 1
    fi

    # Shift the first two arguments since they are already captured
    shift 2

    start_pretty="$(date --date="@$start_epoch" --rfc-3339=seconds)"
    end_pretty="$(date --date="@$end_epoch" --rfc-3339=seconds)"

    echo -e "\e[34mReading logs and filtering for entries from \e[4m$start_pretty\e[24m to \e[4m$end_pretty\e[24m...\e[0m" >&2

    for file in "$@"; do
        echo -e "\e[34mProcessing log file: \e[4m$file\e[0m" >&2
        # Process each log file
        process_log_file "$start_epoch" "$end_epoch" "$file"
    done
}

# Main script execution
if [[ $# -lt 3 ]]; then
    show_help
    exit 1
fi

read_logs "$@"
